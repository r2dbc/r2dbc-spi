[[datatypes]]
= Data Types

This chapter discusses the use of data types from Java and database perspectives.
The R2DBC SPI gives applications access to data types that are defined as SQL.
R2DBC is not limited to SQL types, and, in fact, the SPI is type-agnostic.

If a data source does not support a data type described in this chapter, a driver for that data source is not required to implement the methods and interfaces associated with that data type.

[[datatypes.mapping]]
== Mapping of Data Types

This section explains how SQL-specific types map to Java types.
The list is not exhaustive and should be received as a guideline for drivers.
R2DBC drivers should use modern types and type descriptors to exchange data for consumption by applications and consumption by the driver.
Driver implementations should implement the following type mapping and can support additional type mappings:

* <<datatypes.mapping.char,Character Types>>
* <<datatypes.mapping.boolean,Boolean Types>>
* <<datatypes.mapping.binary,Binary Types>>
* <<datatypes.mapping.numeric,Numeric Types>>
* <<datatypes.mapping.datetime,Datetime Types>>
* <<datatypes.mapping.collection,Collection Types>>

The following table describes the SQL type mapping for character types:

[[datatypes.mapping.char]]
.SQL Type Mapping for Character Types
|===
|SQL Type|Description |Java Type

| `CHARACTER` (`CHAR`)
| Character string, fixed length.
| `java.lang.String`

| `CHARACTER VARYING` (`VARCHAR`)
| Variable-length character string, maximum length fixed.
| `java.lang.String`

| `NATIONAL CHARACTER` (`NCHAR`)
| The `NATIONAL CHARACTER` type is the same as `CHARACTER` except that it holds standardized multibyte characters or Unicode characters.
| `java.lang.String`

| `NATIONAL CHARACTER VARYING` (`NVARCHAR`)
| The `NATIONAL CHARACTER VARYING` type is the same as `CHARACTER VARYING` except that it holds standardized multibyte characters or Unicode characters.
| `java.lang.String`

| `CHARACTER LARGE OBJECT` (`CLOB`)
| A Character Large OBject (or `CLOB`) is a collection of character data in a DBMS, usually stored in a separate location that is referenced in the table itself.
Note that drivers may default to `Clob` when materializing a `CLOB` value requires additional database communication.
| `java.lang.String`, `io.r2dbc.spi.Clob`

| `NATIONAL CHARACTER LARGE OBJECT` (`NCLOB`)
| The `NATIONAL CHARACTER LARGE OBJECT` type is the same as `CHARACTER LARGE OBJECT` except that it holds standardized multibyte characters or Unicode characters.
Note that drivers may default to `Clob` when materializing a `NCLOB` value requires additional database communication.
| `java.lang.String`, `io.r2dbc.spi.Clob`

|===

The following table describes the SQL type mapping for boolean types:

[[datatypes.mapping.boolean]]
.SQL Type Mapping for Boolean Types
|===
|SQL Type|Description |Java Type

| `BOOLEAN`
| A value that represents a boolean state.
| `java.lang.Boolean`

|===

The following table describes the SQL type mapping for binary types:

[[datatypes.mapping.binary]]
.SQL Type Mapping for Binary Types
|===
|SQL Type|Description |Java Type

| `BINARY`
| Binary data, fixed length.
| `java.nio.ByteBuffer`

| `BINARY VARYING` (`VARBINARY`)
| A variable-length character string, the maximum length of which is fixed.
| `java.nio.ByteBuffer`

| `BINARY LARGE OBJECT` (`BLOB`)
| A Binary Large OBject (or `BLOB`) is a collection of binary data in a database management system, usually stored in a separate location that is referenced in the table itself.
Note that drivers may default to `Blob` when materializing a `BLOB` value requires additional database communication.
| `java.nio.ByteBuffer`, `io.r2dbc.spi.Blob`

|===

The following table describes the SQL type mapping for numeric types:

[[datatypes.mapping.numeric]]
.SQL Type Mapping for Numeric Types
|===
|SQL Type|Description |Java Type

| `INTEGER`
| Represents an integer. The minimum and maximum values depend on the DBMS (typically 4-byte precision).
| `java.lang.Integer`

| `TINYINT`
| Same as the `INTEGER` type except that it might hold a smaller range of values, depending on the DBMS (typically 1-byte precision).
| `java.lang.Byte`

| `SMALLINT`
| Same as the `INTEGER` type except that it might hold a smaller range of values, depending on the DBMS (typically 1- or 2-byte precision).
| `java.lang.Short`

| `BIGINT`
| Same as the `INTEGER` type except that it might hold a larger range of values, depending on the DBMS (typically 8-byte precision).
| `java.lang.Long`

| `DECIMAL(p, s)`, `NUMERIC(p, s)`
| Fixed precision and scale numbers with precision (`p`) and scale (`s`). In other words, a number that can have a decimal point in it.
| `java.math.BigDecimal`

| `FLOAT(p)`
| Represents an approximate numerical with mantissa precision (`p`). Databases that use IEEE representation can map values to either 32-bit or 64-bit floating point types depending on the precision parameter (`p`).
| `java.lang.Double` or `java.lang.Float`

| `REAL`
| Same as the `FLOAT` type except that the DBMS defines the precision.
| `java.lang.Float`

| `DOUBLE PRECISION`
| Same as the `FLOAT` type except that the DBMS defines the precision. It has greater precision than `REAL`.
| `java.lang.Double`

|===

The following table describes the SQL type mapping for datetime types:

[[datatypes.mapping.datetime]]
.SQL Type Mapping for Datetime Types
|===
|SQL Type|Description |Java Type

| `DATE`
| Represents a date without specifying a time part and without a timezone.
| `java.time.LocalDate`

| `TIME`
| Represents a time without a date part and without a timezone.
| `java.time.LocalTime`

| `TIME WITH TIME ZONE`
| Represents a time with a timezone offset.
| `java.time.OffsetTime`

| `TIMESTAMP`
| Represents a date and time without a timezone.
| `java.time.LocalDateTime`

| `TIMESTAMP WITH TIME ZONE`
| Represents a date and time with a timezone offset.
| `java.time.OffsetDateTime`

|===

The following table describes the SQL type mapping for collection types:

[[datatypes.mapping.collection]]
.SQL Type Mapping for Collection Types
|===
|SQL Type|Description |Java Type

| `COLLECTION`
( `ARRAY`, `MULTISET` )
| Represents a collection of items with a base type.
| Array-Variant of the corresponding Java type (for example, `Integer[]` for `INTEGER ARRAY`)

|===

Vendor-specific types (such as spatial data types, structured JSON or XML data, and user-defined types) are subject to vendor-specific mapping.

[[datatypes.descriptor]]
== Type Descriptors

R2DBC drivers may infer the database type for inbound parameters or use a specific type.
R2DBC's type system `io.r2dbc.spi.Type` and `io.r2dbc.spi.Parameter` are interfaces to describe a database type and a typed parameter.
The R2DBC specification defines its type mapping in the `io.r2dbc.spi.R2dbcType` utility for commonly used data types. R2DBC drivers may provide their own `Type` objects to provide vendor-specific type support.

[[datatypes.mapping.advanced]]
== Mapping of Advanced Data Types

The R2DBC SPI declares default mappings for advanced data types.The following list describes data types and the interfaces to which they map:

* `BLOB`: The `Blob` interface
* `CLOB`: The `Clob` interface

[[datatypes.lob]]
=== `Blob` and `Clob` Objects

An implementation of a `Blob` or `Clob` object may either be locator-based or fully materialize the object in the driver.
Drivers should prefer locator-based `Blob` and `Clob` interface implementations to reduce pressure on the client when materializing results.

For implementations that fully materialize Large OBjects (LOBs), the `Blob` and `Clob` objects remain valid until the LOB is consumed or the `discard()` method is called.

Portable applications should not depend upon the LOB validity past the end of a transaction.

[[datatypes.lob.create]]
=== Creating `Blob` and `Clob` Objects

Large objects are backed by a `Publisher` that emits the component type of the large object, such as `ByteBuffer` for `BLOB` and `CharSequence` (or a subtype of it) for `CLOB`.

Both interfaces provide factory methods to create implementations to be used with `Statement`.
The following example shows how to create a `Clob` object:

.Creating and using a `Clob` object
====
[source,java]
----
// charstream is a Publisher<String> object
  // statement is a Statement object
Clob clob = Clob.from(charstream);
statement.bind("text", clob);
----
====

[[datatypes.lob.retrieve]]
=== Retrieving `Blob` and `Clob` Objects from a `Readable`

The Binary Large OBject (`BLOB`) and Character Large OBject (`CLOB`) data types are treated similarly to primitive built-in types.
You can retrieve values of these types by calling the `get(…)` methods on the `Readable` interface.
The following example shows how to do so:

.Retrieving a `Clob` object
====
[source,java]
----
// result is a Result object
Publisher<Clob> clob = result.map((readable) -> readable.get("clob", Clob.class));
----
====

The `Blob` and `Clob` interfaces contain methods for returning the content and for releasing resources associated with the object instance.
The API documentation provides more details.

NOTE: LOB value consumption requires special attention due to large object capacity needs. <<datatypes.mapping>> defines a default LOB mapping using scalar types.
The actual default data type for LOB data types can be vendor-specific to avoid blocking if the database requires LOB materialization from a locator or requires database communication during retrieval.

[[datatypes.lob.data]]
=== Accessing `Blob` and `Clob` Data

The `Blob` and `Clob` interfaces declare methods to consume the content of each type.
Content streams follow Reactive Streams specifications and reflect the stream nature of large objects.
As a result, `Blob` and `Clob` objects can be consumed only once.
Large object data consumption can be canceled by calling the `discard()` method if the content stream was not consumed at all.Alternatively, if the content stream was consumed, a `Subscription` cancellation releases resources that are associated with the large object.

The following example shows how to consume `Clob` contents:

.Creating and using a `Clob` object
====
[source,java]
----
// clob is a Clob object
Publisher<CharSequence> charstream = clob.stream();
----
====

[[datatypes.lob.releasing]]
=== Releasing `Blob` and `Clob`

`Blob` and `Clob` objects remain valid for at least the duration of the transaction in which they are created.
This could potentially result in an application running out of resources during a long-running transaction.
Applications may release `Blob` and `Clob` by either consuming the content stream or disposing of resources by calling the `discard()` method.

The following example shows how to free `Clob` resources without consuming it:

.Freeing `Clob` object resources
====
[source,java]
----
// clob is a Clob object
Publisher<Void> charstream = clob.discard();
charstream.subscribe(…);
----
====
